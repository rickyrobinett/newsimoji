"use strict";class e extends Error{key;constructor(e){super(e),this.message=e}}class t extends e{constructor(e){super(e)}}class r{static isParameter=!0;isParameter=!0;type="string";params;generated;constructor(e){this.params=e||{},this.generated=!0,void 0===this.params.required&&(this.params.required=!0)}getValue(){const e={type:this.type,description:this.params.description,example:this.params.example,default:this.params.default};return this.params.deprecated&&(e.deprecated=this.params.deprecated),e}validate(e){return e}}class s extends r{isArr=!0;innerType;constructor(e,t){super(t),this.innerType=e}validate(e){return e=super.validate(e),!1!==this.params.required||null!==e&&""!==e?e=Array.isArray(e)?e.map((e=>this.innerType.validate(e))):[this.innerType.validate(e)]:null}getValue(){return{type:"array",items:this.innerType.getValue(),description:this.params.description,example:this.params.example,default:this.params.default}}}class a extends r{isObj=!0;fields;constructor(e,t){super(t),this.fields=e}validate(e){e=super.validate(e);for(const[r,s]of Object.entries(this.fields))try{if(void 0===e[r]||null===e[r]){if(s.params.required)throw new t("is required")}else e[r]=s.validate(e[r])}catch(e){throw e.key=(e.key||"")+`.${r}`,e}return e}getValue(){const e={type:"object",properties:{}},t=[];for(const[r,s]of Object.entries(this.fields))!0===s.params?.required&&t.push(r),s.getValue?e.properties[r]=s.getValue():e.properties[r]=s;return t.length>0&&(e.required=t),this.params.xml&&(e.xml=this.params.xml),e}}class n extends r{type="number";validate(e){if(e=super.validate(e),e=Number.parseFloat(e),isNaN(e))throw new t("is not a valid number");return e}}class i extends r{type="string";constructor(e){super(e)}validate(e){if("string"!=typeof(e=super.validate(e))&&(e=e.toString()),this.params.format)if("date-time"===this.params.format){if(e=new Date(e),isNaN(e.getDay()))throw new t("is not a valid date time")}else if("date"===this.params.format){if(!e.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/))throw new t("is not a valid date");if(e=new Date(e),isNaN(e.getDay()))throw new t("is not a valid date")}return e}getValue(){return{...super.getValue(),format:this.params.format}}}class o extends i{type="string";constructor(e){super({example:"2022-09-15T00:00:00Z",...e,format:"date-time"})}}class p extends i{type="boolean";validValues=["true","false"];validate(e){if(e=(e=super.validate(e)).toLowerCase(),!this.validValues.includes(e))throw new t("is not a valid boolean, allowed values are true or false");return e="true"===e}}class c{location;rawType;type;params;constructor(e,t,r){this.location=e,this.rawType=t,void 0===r.required&&(r.required=!0),this.params=r,this.type=this.getType(t,r)}getType(e,t){if(!0===e.generated)return e;if(!0===e.isParameter)return new e({...t});if(e===String)return new i({...t});if("string"==typeof e)return new i({example:e});if(e===Number)return new n({...t});if("number"==typeof e)return new n({example:e});if(e===Boolean)return new p({...t});if("boolean"==typeof e)return new p({example:e});if(e===Date)return new o;if(Array.isArray(e)){if(0===e.length)throw new Error("Arr must have a type");return new s(this.getType(e[0],t),{...t})}if("object"==typeof e){const r={};for(const[t,s]of Object.entries(e))r[t]=this.getType(s,{});return new a(r,t)}throw new Error(`${e} not implemented`)}getValue(){const e=m(this.type.getValue());return{description:this.params.description,required:this.params.required,schema:e,name:this.params.name,in:this.location}}validate(e){if(null==e){if(void 0===this.params.default||null===this.params.default){if(this.params.required)throw new t("is required");return null}e=this.params.default}return e=this.type.validate(e)}}class u extends c{paramsBody;constructor(e,t){super(null,e,{}),this.paramsBody=t}getValue(){const e=m(this.type.getValue()),t={description:this.paramsBody?.description,content:{}};return t.content[this.paramsBody?.contentType||"application/json"]={schema:e},t}}class l extends c{constructor(e,t){super(null,e,t)}getValue(){const e=super.getValue(),t=this.params?.contentType?this.params?.contentType:"application/json",r={description:this.params.description||"Successful Response",content:{}};return r.content[t]={schema:e.schema},r}}function d(e,t,r,s){if("query"===s)return t[r];if("path"===s)return e.params[r];if("header"===s)return e.headers.get(r);if("cookie"===s)throw new Error("Cookie parameters not implemented yet")}function m(e){for(const[t,r]of Object.entries(e))"object"!=typeof r||Array.isArray(r)||(e[t]=m(r)),void 0===r&&delete e[t];return e}function h(e){const t=[],r=Array.isArray(e);for(const[s,a]of Object.entries(e||{})){if(r&&!a.params.name)throw new Error("Parameter must have a defined name when using as Array");const e=a.params.name?a.params.name:s;t.push({...a.getValue(),name:e})}return t}exports.OpenAPIRoute=class{static isRoute=!0;static schema;params;constructor(e){this.params=e}static getSchema(){return this.schema}get schema(){return this.__proto__.constructor.schema}getSchema(){return this.__proto__.constructor.getSchema()}static getParsedSchema(){const e=this.getSchema();let t=null;e.requestBody&&(t=new u(e.requestBody,{contentType:e.requestBody.contentType}).getValue());const r={};if(e.responses)for(const[t,s]of Object.entries(e.responses)){const e=new l(s.schema,s);r[t]=e.getValue()}return{...e,parameters:e.parameters?h(e.parameters):[],responses:r,...t?{requestBody:t}:{}}}jsonResp(e){return new Response(JSON.stringify(e.data),{headers:{"content-type":"application/json;charset=UTF-8"},status:e.status||200})}handleValidationError(e){return this.jsonResp({data:{errors:e,success:!1,result:{}},status:400})}async execute(...e){const{data:t,errors:r}=await this.validateRequest(e[0]);if(Object.keys(r).length>0)return this.handleValidationError(r);e.push(t);const s=await this.handle(...e);return s instanceof Response||"object"!=typeof s?s:this.jsonResp({data:s})}async validateRequest(e){const t=this.getSchema().parameters||{},r=this.getSchema().requestBody,s=function(e){const t=decodeURIComponent(e.url).split("?");if(1===t.length)return{};const r=t.slice(1).join("?"),s={};for(const e of r.split("&")){const t=e.split("="),r=t[0],a=t[1];void 0===s[r]?s[r]=a:Array.isArray(s[r])?s[r].push(a):s[r]=[s[r],a]}return s}(e),a={},n={};if(this.params?.raiseUnknownParameters)for(const e of Object.keys(s))if(Array.isArray(t)){let r=!1;for(const s of t)if(s.params.name===e){r=!0;break}r||(n[e]="is an unknown parameter")}else void 0===t[e]&&(n[e]="is an unknown parameter");for(const[r,i]of Object.entries(t)){const t=i,o=t.params.name?t.params.name:r,p=d(e,s,o,t.location);try{a[o]=t.validate(p)}catch(e){n[o]=e.message}}if("get"!==e.method.toLowerCase()&&r&&(void 0===r.contentType||"application/json"===r.contentType)){let t,s=!1;try{t=await e.json(),s=!0}catch(e){n.body=e.message}if(s)try{a.body=new u(r).validate(t)}catch(e){n["body"+e.key]=e.message}}return{data:a,errors:n}}handle(...e){throw new Error("Method not implemented.")}};
